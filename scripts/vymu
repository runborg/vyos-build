#!/usr/bin/env python3
#
# Copyright (C) 2019, VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# File: check-qemu-install
# Purpose:
#  This script installs a system on a emulated qemu host to verify
#  that the iso produced is installable and boots.
#  after the iso is booted from disk it also tries to execute the
#  vyos-smoketest script to verify checks there.
#
#  For now it will not fail on failed smoketest but will fail on
#  install and boot errors.
#  Arguments:
#    iso            iso image to install
#    [disk]         disk filename to use, if none is provided it
#                   is autogenerated
#    [--keep]       Keep the disk image after completion
#    [--logfile]    name of logfile to save, defaulting to stdout
#    [--silent]     only print on errors
#    [--debug]      print all communication with the device

import pexpect
import sys
import os
import time
import argparse
import subprocess
# import random
import traceback
import logging
import re
# import yaml
# from io import BytesIO, StringIO
from datetime import timedelta
import time

DESCRIPTION = '''
    Virtual Machine utility to test virtual instances of VyOS
'''

CONFIG_FILE = '~/.vyemu.conf'

DEFAULT_CONFIG = {
    'DISK_DIR': './',
    'DISK_NAME': 'vymu-vm{ID:02d}.img',
}


# Create an object that converta a stream to line by line log messages used by pexpect
class StreamToLogger(object):
    """
    Fake file-like stream object that redirects writes to a logger instance.
    """
    def __init__(self, logger, log_level=logging.INFO):
        self.logger = logger
        self.log_level = log_level
        self.linebuf = b''
        self.ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')

    def write(self, buf):
        self.linebuf += buf
        while b'\n' in self.linebuf:
            f = self.linebuf.split(b'\n', 1)
            if len(f) == 2:
                self.logger.debug(self.ansi_escape.sub('', f[0].decode(errors="replace").rstrip()))
                self.linebuf = f[1]

    def flush(self):
        pass

# Setting up logger
log = logging.getLogger(__name__)
logStream = StreamToLogger(log)

def get_qemu_cmd(name, enable_kvm, disk, iso=None):
    kvm = ""
    cpu = "-cpu host"
    if not enable_kvm:
        kvm = "--no-kvm"
        cpu = ""

    cdrom = ""
    if iso:
        cdrom = "-boot d -cdrom {}".format(iso)

    cmd = f'qemu-system-x86_64 \
        -name "{name}" \
        -m 1G \
        -nic user,model=virtio,mac=52:54:99:12:34:56 \
        -nic user,model=virtio,mac=52:54:99:12:34:57 \
        -nic user,model=virtio,mac=52:54:99:12:34:58 \
        -nic user,model=virtio,mac=52:54:99:12:34:59 \
        -machine accel=kvm \
        {cpu} \
        -smp 2 \
        -nographic \
        {cdrom} \
        {kvm} \
        -drive format=raw,file={disk}'
    return cmd





def command_sequencer(seq, child):
    """
    Generate a sequence of expect commands from a template

    The template is read line by line and splits the command and data by the
    first colon on that line: 

    Example template:
    --------
    info: save config
    find: \nsave config?
    send: yes
    --------

    supported commands: 
    info: Sends an info message to the logger
    send: send a line to the session, automatically sends newline at the end
    find: regex to match, creates an exeption on timeout
    timeout: sets the timeout value for the next find command in seconds
             reset to default timeout by 'timeout: default'
    wait_for_poweroff: Waits for session to become idle and vm to poweroff
    sleep: sleep parsing and wait for X sec
    command: send a command and wait for a new prompt, also reads the last commands errorlevel
    """
    timeout = None
    for _line in seq.splitlines():
        line = _line.lstrip()
        if not line or line.startswith("#"):
            # Skip empty lines and comments
            continue
        command, data = re.split(r":[ \t]?", line, 1)
        if command == 'info':
            log.info(data)

        elif command == 'send':
            child.sendline(data)

        elif command == 'find':
            child.expect(data, timeout=timeout if timeout else -1)

        elif command == 'timeout':
            if data == 'default':
                timeout = -1
            else:
                timeout = int(data)

        elif command == 'wait_for_poweroff':
            for i in range(30):
                log.info('Waiting for shutdown...')
                if not child.isalive():
                    log.info('VM is shut down!')
                    break
                time.sleep(10)
            else:
                log.error('VM Did not shut down after 300sec')
                raise Exception("VM Did not shut down after 300sec")

        elif command == 'sleep':
            time.sleep(int(data))

        elif command == 'command':
            child.sendline(data)
            i = c.expect([r'\n +Invalid command:',
                          r'\n +Set failed',
                          r'No such file or directory',
                          r'\n\S+@\S+[$#]'], timeout=3600)
            if i == 0:
                raise Exception('Invalid command detected')
            elif i == 1:
                raise Exception('Set syntax failed :/')
            elif i == 2:
                raise Exception("File not found returned from command")

            child.sendline('echo EXITCODE:$\x16?')
            i = c.expect([r'EXITCODE:0', r'EXITCODE:\d+'], timeout=10)
            if i == 0:
                log.info('Command finished successfully!')
                pass
            if i == 1:
                log.error('Command failed :/')
                raise Exception("command failed, please look into debug output")

            child.expect(r'\n\S+@\S+[$#]')

        else:
            Exception(f"Unknown syntax '{command}'")



class Vyemu():
    def __init__(self, disk_image, kvm=True):
        # TODO: Validate disk image
        self.disk_image = disk_image
        self.kvm = kvm

    def create_disk(self, size=2048, overwrite=False):
        """
        Create a new qemu disk image
        """
        if not isinstance(size, int):
            raise ValueError('Size needs to be an integer value')
        if not overwrite and not os.path.isfile(self.disk_image):
            log.info(f'Creating Disk image {self.disk_image}')
            subprocess.check_output(f'qemu-img create {self.disk_image} {size:d}m')
            return True
        raise FileExistsError(f'The file specified {self.disk_image} and owerwriting files is disabled')

    def delete_disk(self):
        log.info(f'Removing disk file: {self.disk_image}')
        os.remove(self.disk_image)

    def install_vyos(self, iso, autocreate=True):
        if not os.path.isfile(iso):
            raise FileNotFoundError(f'ISO file {iso} does not exist')

        if not os.path.isfile(self.disk_image):
            if not autocreate:
                raise FileNotFoundError(f'The disk file {self.disk_image} is not existant and autocreate is disabled')
            log.info('Disk image not found, creating using default config')
            self.create_disk()

        try:
            log.info("Installing System")
            cmd = get_qemu_cmd("TESTVM", self.kvm, disk=self.disk_image, iso=iso)
            log.debug("Executing command: {cmd}")
            c = pexpect.spawn(cmd, logfile=logStream)

            # Skipping Grub
            try:
                c.expect(['Automatic boot in', 'ISOLINUX.*\n'], timeout=10)
                c.sendline('')
            except pexpect.TIMEOUT:
                log.warning("Did not find grub countdown window, ignoring")
            
            # Execute the install sequence
            command_sequencer(LOGIN + INSTALL_OS + POWEROFF, c)

            c.close()
            log.info("Image installed successfully")

        except pexpect.exceptions.TIMEOUT:
            log.error("Timeout waiting for VyOS system")
            log.error(traceback.format_exc())
            raise

        except pexpect.exceptions.ExceptionPexpect:
            log.error("Exeption while executing QEMU")
            log.error("Is qemu working on this system?")
            log.error(traceback.format_exc())
            raise

        except Exception:
            log.error("An unknown error occured when installing the VyOS system")
            log.error(traceback.format_exc())
            raise

    def run(self, iso=None):
        """
        Execute an interactive session with the device, all controll is handed over to qemu
        and stdin/stdout is sent directly to the user
        """
        if iso and not os.path.isfile(iso):
            raise FileNotFoundError(f'ISO file {iso} does not exist')

        if not os.path.isfile(self.disk_image):
            raise FileNotFoundError('Disk image not found, please create before executing')

        log.info("-------------------------------------------------------------")
        log.info("Booting into an interactive VyOS system                      ")
        log.info("Power down the VM or Press ctrl+a x to terminate the session ")
        log.info("-------------------------------------------------------------")
        cmd = get_qemu_cmd("TESTVM", self.kvm, disk=self.disk_image, iso=iso)
        subprocess.run(cmd, shell=True)

    def smoketest(self):
        """
        Execute the smoketest suite on this install
        """
        if not os.path.isfile(self.disk_image):
            raise FileNotFoundError(f'Disk image {self.disk_image}, please create and install before running')

        try:
            log.info("Booting installed system")
            cmd = get_qemu_cmd("TESTVM", config['kvm'], args.disk)
            log.debug(f'Executing command: {cmd}')
            c = pexpect.spawn(cmd, logfile=logStream)
            try:
                c.expect('The highlighted entry will be executed automatically in', timeout=10)
                c.sendline('')
            except pexpect.TIMEOUT:
                log.warning("Did not find grub countdown window, ignoring")

            command_sequencer(LOGIN + BASIC_TEST + SMOKETEST + POWEROFF, c)
            c.close()

        except pexpect.exceptions.TIMEOUT:
            log.error("Timeout waiting for VyOS system")
            log.error(traceback.format_exc())
            raise

        except pexpect.exceptions.ExceptionPexpect:
            log.error("Exeption while executing QEMU")
            log.error("Is qemu working on this system?")
            log.error(traceback.format_exc())
            raise

        except Exception:
            log.error("An unknown error occured when installing the VyOS system")
            traceback.print_exc()
            raise



def do_create(app, rgs, config):
    app.create_disk(overwrite=True)

def do_delete(app, args, config):
    app.delete_disk()

def do_list(app, args, config):
    print("LIST - NOT IMPLEMENTED")

def do_install(app, args, config):
    app.install_vyos(args.iso)
    
def do_run(app, args, config):
    app.run()

def do_bootiso(app, args, config):
    app.run(args.iso)

def do_smoketest(args, config, log):
    app.smoketest()





# Command sequences
LOGIN = r'''
    #################################################
    # Logging into VyOS system
    #################################################
    info: Waiting for login prompt
    timeout: 300
    find: [Ll]ogin:
    timeout: default
    send: vyos
    find: [Pp]assword:
    send: vyos
    find: vyos@vyos:~\$
    info: Logged in!
    sleep: 10
    '''

INSTALL_OS = r'''
    #################################################
    # Installing into VyOS system
    #################################################
    info: Starting installer
    send: install image
    find: \nWould you like to continue?.*:
    send: yes
    info: Partitioning disk
    find: \nPartition.*:
    send:
    find: \nInstall the image on.*:
    send:
    find: \nContinue\?.*:
    send: yes
    find: How big of a root partition should I create?.*:
    send:

    info: Installing
    find: \nWhat would you like to name this image?.*:
    send:
    info: Copying files
    timeout: 300
    find: \nWhich one should I copy to.*:
    timeout: default
    send:
    log: Files copied!

    find: \nEnter password for user.*:
    send: vyos
    find: \nRetype password for user.*:
    send: vyos
    find: \nWhich drive should GRUB modify the boot partition on.*:
    send:
    find: \nvyos@vyos:~\$
    info: system installed

    '''
POWEROFF = r'''
    #################################################
    # Shutting down
    #################################################

    log: Shutting down installation system
    send: poweroff
    find: \nAre you sure you want to poweroff this system.*\]
    send: Y

    wait_for_poweroff:
    '''

BASIC_TEST = r'''
    info: Basic CLI Configuration mode test
    command: configure
    command: run show version
    command: exit
    '''

SMOKETEST = r'''
    log: Executing smoketest test-suite
    command: /usr/bin/vyos-smoketest
    '''


def main():
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument('-i', '--id', help='ID number of the virtual instance to manage',
                              type=int,
                              default=1,
                        )
    parser.add_argument('--no-kvm', help='Disable KVM', action='store_true')
    parser.add_argument('--debug',
                        help='Enable debug logging',
                        action='store_true',
                        default=False)
    parser.add_argument('--silent',
                        help='Disable all logging',
                        action='store_true',
                        default=False)

    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    create_parser = subparsers.add_parser('create', help='Create a new virtual image to install vyos into')
    create_parser.set_defaults(func=do_create)

    delete_parser = subparsers.add_parser('delete', help='Delete a virtual image')
    delete_parser.set_defaults(func=do_delete)

    list_parser = subparsers.add_parser('list', help='List all available virtual instances found')
    list_parser.set_defaults(func=do_list)

    install_parser = subparsers.add_parser('install', help='Automatically install a ISO to a virtual image')
    install_parser.set_defaults(func=do_install)
    install_parser.add_argument('iso', help='ISO file to install')

    run_parser = subparsers.add_parser('run', help='Run a installed virtual instance and enter the shell')
    run_parser.set_defaults(func=do_run)

    bootiso_parser = subparsers.add_parser('bootiso', help='Boot an iso for manual installation of vyos')
    bootiso_parser.set_defaults(func=do_bootiso)
    bootiso_parser.add_argument('iso', help='ISO file to boot')

    smoketest_parser = subparsers.add_parser('smoketest', help='Execute the smoketest testing suite on a virtual instance')
    smoketest_parser.set_defaults(func=do_smoketest)
    args = parser.parse_args()

    class ElapsedTimeFormatter():
        def __init__(self):
            self.init_time = time.time()

        def format(self, record):
            elapsed = float(timedelta(seconds=record.created - self.init_time).total_seconds())
            return f'{elapsed:04.4f} {record.levelname:>7s} - {record.getMessage():s}'
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(ElapsedTimeFormatter())
    log.addHandler(console)

    if args.silent:
        log.setLevel(logging.ERROR)
    elif args.debug:
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    config = DEFAULT_CONFIG.copy()
    if not config['DISK_DIR'].endswith('/'):
        config['DISK_DIR'] += '/'

    if args.no_kvm:
        log.error("KVM forced off by command line")
        config['kvm'] = False
    elif not os.path.exists("/dev/kvm"):
        log.error("KVM is not enabled on host, proceeding with software emulation")
        config['kvm'] = False
    else:
        config['kvm'] = True

    # Generate Path for disk image
    config['disk_path'] = os.path.expanduser(config['DISK_DIR'] + config['DISK_NAME'].format(ID=args.id))

    app = Vyemu(disk_image=config['disk_path'], kvm=config['kvm'])

    # Execute the command scripts
    args.func(app, args, config)


if __name__ == "__main__":
    main()
