#!/usr/bin/env python3
#
# Copyright (C) 2019, VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# File: check-qemu-install
# Purpose:
#  This script installs a system on a emulated qemu host to verify
#  that the iso produced is installable and boots.
#  after the iso is booted from disk it also tries to execute the
#  vyos-smoketest script to verify checks there.
#
#  For now it will not fail on failed smoketest but will fail on
#  install and boot errors.
#  Arguments:
#    iso            iso image to install
#    [disk]         disk filename to use, if none is provided it
#                   is autogenerated
#    [--keep]       Keep the disk image after completion
#    [--logfile]    name of logfile to save, defaulting to stdout
#    [--silent]     only print on errors
#    [--debug]      print all communication with the device

import pexpect
import sys
import os
import time
import argparse
import subprocess
import random
import traceback
import logging
import re
import yaml
from io import BytesIO, StringIO
from datetime import datetime

DESCRIPTION =  '''
    Virtual Machine utility to test virtual instances of VyOS


'''

CONFIG_FILE = '~/.vyemu.conf'

DEFAULT_CONFIG = {
    'DISK_DIR': './',
    'DISK_NAME': 'vymu-vm{ID:02d}.img',
}


def get_qemu_cmd(name, enable_kvm, disk, iso=None):
    kvm = ""
    cpu = "-cpu host"
    if not enable_kvm:
        kvm = "--no-kvm"
        cpu = ""

    cdrom = ""
    if iso:
        cdrom = "-boot d -cdrom {}".format(iso)

    cmd = f'qemu-system-x86_64 \
        -name "{name}" \
        -m 1G \
        -nic user,model=virtio,mac=52:54:99:12:34:56 \
        -nic user,model=virtio,mac=52:54:99:12:34:57 \
        -nic user,model=virtio,mac=52:54:99:12:34:58 \
        -nic user,model=virtio,mac=52:54:99:12:34:59 \
        -machine accel=kvm \
        {cpu} \
        -smp 2 \
        -nographic \
        {cdrom} \
        {kvm} \
        -drive format=raw,file={disk}'

    return cmd


class StreamToLogger(object):
    """
    Fake file-like stream object that redirects writes to a logger instance.
    """
    def __init__(self, logger, log_level=logging.INFO):
        self.logger = logger
        self.log_level = log_level
        self.linebuf = b''
        self.ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')

    def write(self, buf):
        self.linebuf += buf
        # print('.')
        while b'\n' in self.linebuf:
            f = self.linebuf.split(b'\n', 1)
            if len(f) == 2:
                self.logger.debug(self.ansi_escape.sub('', f[0].decode(errors="replace").rstrip()))
                self.linebuf = f[1]
            # print(f)

    def flush(self):
        pass


def command_sequencer(seq, child):
    timeout = None
    for _line in seq.splitlines():
        line = _line.lstrip()
        if not line or line.startswith("#"):
            # Skip empty lines and comments
            continue
        command, data = re.split(r":[ \t]?", line, 1)
        if command == 'info':
            log.info(data)

        elif command == 'send':
            child.sendline(data)

        elif command == 'find':
            child.expect(data, timeout=timeout if timeout else -1)

        elif command == 'timeout':
            if data == 'default':
                timeout = -1
            else:
                timeout = int(data)

        elif command == 'wait_for_poweroff':
            for i in range(30):
                log.info('Waiting for shutdown...')
                if not child.isalive():
                    log.info('VM is shut down!')
                    break
                time.sleep(10)
            else:
                log.error('VM Did not shut down after 300sec')
                raise Exception("VM Did not shut down after 300sec")

        elif command == 'sleep':
            time.sleep(int(data))

        elif command == 'command':
            child.sendline(data)
            i = c.expect([r'\n +Invalid command:',
                          r'\n +Set failed',
                          r'No such file or directory',
                          r'\n\S+@\S+[$#]'], timeout=3600)
            if i == 0:
                raise Exception('Invalid command detected')
            elif i == 1:
                raise Exception('Set syntax failed :/')
            elif i == 2:
                raise Exception("File not found returned from command")

            child.sendline('echo EXITCODE:$\x16?')
            i = c.expect([r'EXITCODE:0', r'EXITCODE:\d+'], timeout=10)
            if i == 0:
                log.info('Command finished successfully!')
                pass
            if i == 1:
                log.error('Command failed :/')
                raise Exception("command failed, please look into debug output")

            child.expect(r'\n\S+@\S+[$#]')

        else:
            Exception(f"Unknown syntax '{command}'")


def do_create(args, config, log, stl):
    if not os.path.isfile(config['disk_path']):
        log.info("Creating Disk image {}".format(config['disk_path']))
        _c = subprocess.check_output(["qemu-img", "create", config['disk_path'], "2G"])
        # log.debug(_c.decode())
    else:
        log.error("Diskimage already exists, please delete prior to recreation")


def do_delete(args, config, log, stl):
    log.info("Removing disk file: {}".format(config['disk_path']))
    try:
        os.remove(config['disk_path'])
    except Exception:
        log.error(traceback.format_exc())
        os.exit("Exception while removing diskimage")


def do_list(args, config, log, stl):
    print("LIST - NOT IMPLEMENTED")


def do_install(args, config, log, stl):
    if not os.path.isfile(args.iso):
        sys.exit("ISO file does not exist")

    if not os.path.isfile(config['disk_path']):
        log.info('Disk image not found, creating using default config')
        do_create(args, config)

    try:
        log.info("Installing System")
        cmd = get_qemu_cmd("TESTVM", config['kvm'], disk=config['disk_path'], iso=args.iso)
        log.debug("Executing command: {cmd}")
        c = pexpect.spawn(cmd, logfile=stl)

        # Skipping Grub
        try:
            c.expect('Automatic boot in', timeout=10)
            c.sendline('')
        except pexpect.TIMEOUT:
            log.warning("Did not find grub countdown window, ignoring")
        command_sequencer(LOGIN + INSTALL_OS + POWEROFF, c)
        c.close()
        log.info("Image installed successfully")
    except pexpect.exceptions.TIMEOUT:
        log.error("Timeout waiting for VyOS system")
        log.error(traceback.format_exc())

    except pexpect.exceptions.ExceptionPexpect:
        log.error("Exeption while executing QEMU")
        log.error("Is qemu working on this system?")
        log.error(traceback.format_exc())

    except Exception:
        log.error("An unknown error occured when installing the VyOS system")
        log.error(traceback.format_exc())


def do_run(args, config, log, stl):
    if not os.path.isfile(config['disk_path']):
        os.exit('Disk image not found, please create and install before running')
    log.info("-------------------------------------------------------")
    log.info("Installing image and Booting into an interactive system")
    log.info("to Power down the VM or Press ctrl+a x to terminate")
    log.info("or shutdown vm by the 'poweroff' command")
    log.info("-------------------------------------------------------")
    log.info()

    cmd = get_qemu_cmd("TESTVM", config['kvm'], disk=config['disk_path'])
    subprocess.run(cmd, shell=True)


def do_bootiso(args, config, log, stl):
    if not os.path.isfile(args.iso):
        sys.exit("ISO file does not exist")

    if not os.path.isfile(config['disk_path']):
        log.info('Disk image not found, creating using default config')
        do_create(args, config)
    
    log.info("-------------------------------------------------------")
    log.info("Installing image and Booting into an interactive system")
    log.info("to Power down the VM or Press ctrl+a x to terminate")
    log.info("or shutdown vm by the 'poweroff' command")
    log.info("-------------------------------------------------------")

    cmd = get_qemu_cmd("TESTVM", config['kvm'], disk=config['disk_path'], iso=args.iso)
    subprocess.run(cmd, shell=True)


BASIC_TEST = r'''
    info: Basic CLI Configuration mode test
    command: configure
    command: run show version
    command: exit
    '''

SMOKETEST = r'''
    log: Executing smoketest test-suite
    command: /usr/bin/vyos-smoketest
    '''


def do_smoketest(args, config, log, stl):
    if not os.path.isfile(config['disk_path']):
        os.exit('Disk image not found, please create and install before running')

    try:
        log.info("Booting installed system")
        cmd = get_qemu_cmd("TESTVM", kvm, args.disk)
        log.debug(f'Executing command: {cmd}')
        c = pexpect.spawn(cmd, logfile=stl)
        try:
            c.expect('The highlighted entry will be executed automatically in', timeout=10)
            c.sendline('')
        except pexpect.TIMEOUT:
            log.warning("Did not find grub countdown window, ignoring")

        command_sequencer(LOGIN + BASIC_TEST + SMOKETEST + POWEROFF, c)
        c.close()

    except pexpect.exceptions.TIMEOUT:
        log.error("Timeout waiting for VyOS system")
        log.error(traceback.format_exc())
        os.exit(1)

    except pexpect.exceptions.ExceptionPexpect:
        log.error("Exeption while executing QEMU")
        log.error("Is qemu working on this system?")
        log.error(traceback.format_exc())
        os.exit(1)

    except Exception:
        log.error("An unknown error occured when installing the VyOS system")
        traceback.print_exc()
        os.exit(1)


commands = {
    'create': do_create,
    'delete': do_delete,
    'list': do_list,
    'install': do_install,
    'run': do_run,
    'bootiso': do_bootiso,
    'smoketest': do_smoketest,
}


# Command sequences
LOGIN = r'''
    #################################################
    # Logging into VyOS system
    #################################################
    info: Waiting for login prompt
    timeout: 300
    find: [Ll]ogin:
    timeout: default
    send: vyos
    find: [Pp]assword:
    send: vyos
    find: vyos@vyos:~\$
    info: Logged in!
    sleep: 10
    '''

INSTALL_OS = r'''
    #################################################
    # Installing into VyOS system
    #################################################
    info: Starting installer
    send: install image
    find: \nWould you like to continue?.*:
    send: yes
    info: Partitioning disk
    find: \nPartition.*:
    send:
    find: \nInstall the image on.*:
    send:
    find: \nContinue\?.*:
    send: yes
    find: How big of a root partition should I create?.*:
    send:

    info: Installing
    find: \nWhat would you like to name this image?.*:
    send:
    info: Copying files
    timeout: 300
    find: \nWhich one should I copy to.*:
    timeout: default
    send:
    log: Files copied!

    find: \nEnter password for user.*:
    send: vyos
    find: \nRetype password for user.*:
    send: vyos
    find: \nWhich drive should GRUB modify the boot partition on.*:
    send:
    find: \nvyos@vyos:~\$
    info: system installed

    '''
POWEROFF = r'''
    #################################################
    # Shutting down
    #################################################

    log: Shutting down installation system
    send: poweroff
    find: \nAre you sure you want to poweroff this system.*\]
    send: Y

    wait_for_poweroff:
    '''


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument('-i', '--id', help='ID number of the virtual instance to manage',
                              type=int,
                              default=1,
                        )
    parser.add_argument('--no-kvm', help='Disable KVM', action='store_true')
    parser.add_argument('--debug',
                        help='Enable debug logging',
                        action='store_true',
                        default=False)
    parser.add_argument('--silent',
                        help='Disable all logging',
                        action='store_true',
                        default=False)

    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    create_parser = subparsers.add_parser('create', help='Create a new virtual image to install vyos into')

    delete_parser = subparsers.add_parser('delete', help='Delete a virtual image')

    list_parser = subparsers.add_parser('list', help='List all available virtual instances found')
    
    install_parser = subparsers.add_parser('install', help='Automatically install a ISO to a virtual image')
    install_parser.add_argument('iso', help='ISO file to install')

    run_parser = subparsers.add_parser('run', help='Run a installed virtual instance and enter the shell')

    bootiso_parser = subparsers.add_parser('bootiso', help='Boot an iso for manual installation of vyos')
    bootiso_parser.add_argument('iso', help='ISO file to boot')

    smoketest_parser = subparsers.add_parser('smoketest', help='Execute the smoketest testing suite on a virtual instance')

    args = parser.parse_args()

    # Setting up logger
    log = logging.getLogger()
    log.setLevel(logging.DEBUG)

    stl = StreamToLogger(log)
    formatter = logging.Formatter('%(levelname)5s - %(message)s')

    handler = logging.StreamHandler(sys.stdout)
    if args.silent:
        handler.setLevel(logging.ERROR)
    elif args.debug:
        handler.setLevel(logging.DEBUG)
    else:
        handler.setLevel(logging.INFO)

    handler.setFormatter(formatter)
    log.addHandler(handler)

    config = DEFAULT_CONFIG.copy()
    if not config['DISK_DIR'].endswith('/'):
        config['DISK_DIR'] += '/'

    if args.no_kvm:
        log.error("KVM forced off by command line")
        config['kvm'] = False
    elif not os.path.exists("/dev/kvm"):
        log.error("KVM is not enabled on host, proceeding with software emulation")
        config['kvm'] = False
    else:
        config['kvm'] = True

    # Generate Path for disk image
    config['disk_path'] = os.path.expanduser(config['DISK_DIR'] + config['DISK_NAME'].format(ID=args.id))

    # Execute the command scripts
    commands[args.command](args, config, log, stl)
